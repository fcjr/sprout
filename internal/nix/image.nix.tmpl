let 
  nixos = import <nixpkgs/nixos> {
    system = "aarch64-linux";
    configuration = { lib, pkgs, config, ... }: {
      imports = [
        <nixpkgs/nixos/modules/installer/sd-card/sd-image-aarch64-installer.nix>
      ];
      
      system.stateVersion = "24.11";
      # Create sprout user with SSH access
{{- if .SSHKeys }}
      users.users.sprout = {
        isNormalUser = true;
        extraGroups = [ "wheel"{{- if .DockerCompose.Enabled }} "docker"{{- end }} ];
        openssh.authorizedKeys.keys = [
{{- range .SSHKeys }}
          "{{ . }}"
{{- end }}
        ];
      };
{{- end }}
      # bzip2 compression takes loads of time with emulation, skip it.
      sdImage.compressImage = false;
{{- if .DockerCompose.Enabled }}
      # Allow the image to expand on boot to accommodate Docker containers
      sdImage.expandOnBoot = true;
      # Increase firmware partition size slightly for Docker overhead
      sdImage.firmwareSize = lib.mkDefault 50;
{{- end }}
      # OpenSSH is forced to have an empty `wantedBy` on the installer system[1], this won't allow it
      # to be started. Override it with the normal value.
      # [1] https://github.com/NixOS/nixpkgs/blob/9e5aa25/nixos/modules/profiles/installation-device.nix#L76
      systemd.services.sshd.wantedBy = lib.mkOverride 40 [ "multi-user.target" ];
      # Enable OpenSSH out of the box.
      services.openssh.enable = true;
      
      # Add git to system packages
      environment.systemPackages = with pkgs; [{{- if .DockerCompose.Enabled }} docker-compose{{- end }}{{- if .Autodiscovery }} avahi{{- end }}];
      
      # Enable Nix flakes
      nix.settings.experimental-features = [ "nix-command" "flakes" ];
      
      # Raspberry Pi optimizations
      boot.kernelParams = [
        "cgroup_memory=1"
        "cgroup_enable=memory"
      ];

{{- if .DockerCompose.Enabled }}
      # Enable Docker with minimal configuration to save space
      virtualisation.docker.enable = true;
      virtualisation.docker.enableOnBoot = true;
      virtualisation.docker.autoPrune.enable = true;
      # Use smaller log driver and limit log size
      virtualisation.docker.logDriver = "json-file";
      virtualisation.docker.extraOptions = "--log-opt max-size=10m --log-opt max-file=3";
      
      # Create docker-compose.yaml file with local image references
      environment.etc."docker/docker-compose.yaml".text = ''
{{- if .DockerCompose.ModifiedContent }}
{{ .DockerCompose.ModifiedContent }}{{- else }}
{{ .DockerCompose.Content }}{{- end }}      '';
      
{{- if .DockerCompose.Images }}
      # Copy Docker image tar files into the system
{{- range .DockerCompose.Images }}
      environment.etc."docker/images/{{ .LocalTag }}.tar".source = {{ .TarPath }};
{{- end }}
      
      # Create systemd service to load Docker images on first boot
      systemd.services.docker-load-images = {
        description = "Load embedded Docker images";
        requires = [ "docker.service" ];
        after = [ "docker.service" ];
        before = [ "docker-compose.service" ];
        wantedBy = [ "multi-user.target" ];
        serviceConfig = {
          Type = "oneshot";
          RemainAfterExit = "yes";
          ExecStart = let
            loadScript = pkgs.writeShellScript "load-docker-images" ''
              # Load all embedded Docker images
{{- range .DockerCompose.Images }}
              echo "Loading Docker image: {{ .LocalTag }}"
              ${pkgs.docker}/bin/docker load -i /etc/docker/images/{{ .LocalTag }}.tar
{{- end }}
            '';
          in "${loadScript}";
          User = "root";
        };
      };
{{- end }}
      
      # Create systemd service to run docker-compose on boot
      systemd.services.docker-compose = {
        description = "Docker Compose Application Service";
        requires = [ "docker.service"{{- if .DockerCompose.Images }} "docker-load-images.service"{{- end }} ];
        after = [ "docker.service"{{- if .DockerCompose.Images }} "docker-load-images.service"{{- end }} ];
        wantedBy = [ "multi-user.target" ];
        serviceConfig = {
          Type = "oneshot";
          RemainAfterExit = "yes";
          WorkingDirectory = "/etc/docker";
          ExecStart = "${pkgs.docker-compose}/bin/docker-compose up -d";
          ExecStop = "${pkgs.docker-compose}/bin/docker-compose down";
          TimeoutStartSec = "0";
          User = "sprout";
        };
      };
{{- end }}
      
{{- if .Wireless.Enabled }}
      # Configure WiFi without conflicting services
      networking.networkmanager.enable = lib.mkForce false;
      networking.wireless.enable = true;
{{- if .Wireless.Networks }}
      networking.wireless.networks = {
{{- range $ssid, $config := .Wireless.Networks }}
        "{{ $ssid }}" = {
{{- if $config.PSK }}
          psk = "{{ $config.PSK }}";
{{- end }}
        };
{{- end }}
      };
{{- end }}
{{- end }}
      
{{- if .Autodiscovery }}
      # Enable Avahi for mDNS/DNS-SD
      services.avahi = {
        enable = true;
        nssmdns = true;
        publish = {
          enable = true;
          addresses = true;
          domain = true;
          hinfo = true;
          userServices = true;
          workstation = true;
        };
      };
      
      # Copy Sprout binary to the system
      environment.etc."sprout/sprout".source = {{ .SproutBinaryPath }};
      environment.etc."sprout/sprout".mode = "0755";
      
      # Create Avahi service file for Sprout
      environment.etc."avahi/services/sprout.service".text = ''
        <?xml version="1.0" standalone='no'?>
        <!DOCTYPE service-group SYSTEM "avahi-service.dtd">
        <service-group>
          <name replace-wildcards="yes">Sprout on %h</name>
          <service>
            <type>_sprout._tcp</type>
            <port>8080</port>
            <txt-record>sprout discovery service</txt-record>
          </service>
        </service-group>
      '';
      
      # Create systemd service for Sprout daemon
      systemd.services.sprout-daemon = {
        description = "Sprout Discovery Daemon";
        after = [ "network.target" "avahi-daemon.service" ];
        wants = [ "avahi-daemon.service" ];
        wantedBy = [ "multi-user.target" ];
        serviceConfig = {
          Type = "simple";
          ExecStart = "/etc/sprout/sprout daemon --quiet --hostname sprout-node";
          Restart = "always";
          RestartSec = "10";
          User = "root";
          StandardOutput = "journal";
          StandardError = "journal";
        };
      };
{{- end }}
    };
  };
in nixos.config.system.build.sdImage